<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TPM Knowledge Base - Sunburst</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0D0D0D;
      --text-primary: #FAFAFA;
      --text-secondary: #A1A1AA;
    }

    body {
      font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .diagram-frame {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    #sunburst {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .legend-container {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      flex-wrap: wrap;
      padding: 0.75rem 2rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 4px;
    }

    .legend-label {
      font-size: 0.85rem;
      color: var(--text-primary);
      font-weight: 400;
    }

    .center-label {
      font-family: 'IBM Plex Sans', sans-serif;
      fill: var(--text-primary);
      text-anchor: middle;
      pointer-events: none;
    }

    .export-container {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }

    .export-btn {
      padding: 0.6rem 1.5rem;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      color: #FAFAFA;
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .export-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <div class="diagram-frame">
    <div id="sunburst"></div>
    <div class="legend-container" id="legend"></div>
    <div class="export-container">
      <button class="export-btn" onclick="exportPNG()">Download PNG</button>
      <button class="export-btn" onclick="exportSVG()">Download SVG</button>
    </div>
  </div>

  <script>
    const data = {
      "name": "TPM Knowledge Base",
      "children": [
        {
          "name": "DATA",
          "children": [
            {
              "name": "Architecture",
              "children": [
                { "name": "Data Warehouse", "children": [{ "name": "OLAP" }, { "name": "Fact Tables" }] },
                { "name": "Data Lake", "children": [{ "name": "Raw Zone" }, { "name": "Curated Zone" }] },
                { "name": "Star Schema", "children": [{ "name": "Dimensions" }, { "name": "Measures" }] }
              ]
            },
            {
              "name": "Processing",
              "children": [
                { "name": "ETL / ELT", "children": [{ "name": "Extract" }, { "name": "Transform" }] },
                { "name": "Data Pipeline", "children": [{ "name": "Orchestration" }, { "name": "Scheduling" }] },
                { "name": "Batch / Stream", "children": [{ "name": "Micro-batch" }, { "name": "Real-time" }] }
              ]
            },
            {
              "name": "Governance",
              "children": [
                { "name": "Data Quality", "children": [{ "name": "Accuracy" }, { "name": "Completeness" }] },
                { "name": "Data Lineage", "children": [{ "name": "Source" }, { "name": "Transformation" }] },
                { "name": "Data Catalog", "children": [{ "name": "Metadata" }, { "name": "Discovery" }] }
              ]
            }
          ]
        },
        {
          "name": "SOFTWARE",
          "children": [
            {
              "name": "Architecture",
              "children": [
                { "name": "Microservices", "children": [{ "name": "Decoupling" }, { "name": "Scaling" }] },
                { "name": "REST API", "children": [{ "name": "Endpoints" }, { "name": "HTTP Methods" }] },
                { "name": "Event-Driven", "children": [{ "name": "Pub/Sub" }, { "name": "Message Queue" }] }
              ]
            },
            {
              "name": "Patterns",
              "children": [
                { "name": "Design Patterns", "children": [{ "name": "Factory" }, { "name": "Singleton" }] },
                { "name": "SOLID", "children": [{ "name": "Single Resp." }, { "name": "Open/Closed" }] },
                { "name": "Clean Code", "children": [{ "name": "Readability" }, { "name": "Refactoring" }] }
              ]
            },
            {
              "name": "Testing",
              "children": [
                { "name": "Unit Testing", "children": [{ "name": "Mocking" }, { "name": "Assertions" }] },
                { "name": "Integration", "children": [{ "name": "End-to-End" }, { "name": "Contract" }] },
                { "name": "TDD / BDD", "children": [{ "name": "Red-Green" }, { "name": "Specs" }] }
              ]
            }
          ]
        },
        {
          "name": "CLOUD",
          "children": [
            {
              "name": "Infrastructure",
              "children": [
                { "name": "IaC", "children": [{ "name": "Terraform" }, { "name": "ARM/Bicep" }] },
                { "name": "Containers", "children": [{ "name": "Docker" }, { "name": "Images" }] },
                { "name": "Kubernetes", "children": [{ "name": "Pods" }, { "name": "Services" }] }
              ]
            },
            {
              "name": "Services",
              "children": [
                { "name": "Compute", "children": [{ "name": "VMs" }, { "name": "App Service" }] },
                { "name": "Storage", "children": [{ "name": "Blob" }, { "name": "File" }] },
                { "name": "Serverless", "children": [{ "name": "Functions" }, { "name": "Logic Apps" }] }
              ]
            },
            {
              "name": "Resilience",
              "children": [
                { "name": "HA / DR", "children": [{ "name": "Failover" }, { "name": "Geo-Replication" }] },
                { "name": "Load Balancing", "children": [{ "name": "Round Robin" }, { "name": "Health Checks" }] },
                { "name": "Auto-Scaling", "children": [{ "name": "Scale Out" }, { "name": "Scale Up" }] }
              ]
            }
          ]
        },
        {
          "name": "DEVOPS",
          "children": [
            {
              "name": "Deployment",
              "children": [
                { "name": "CI/CD", "children": [{ "name": "Build" }, { "name": "Deploy" }] },
                { "name": "Pipelines", "children": [{ "name": "Stages" }, { "name": "Approvals" }] },
                { "name": "Release Mgmt", "children": [{ "name": "Versioning" }, { "name": "Rollback" }] }
              ]
            },
            {
              "name": "Observability",
              "children": [
                { "name": "Monitoring", "children": [{ "name": "Dashboards" }, { "name": "Metrics" }] },
                { "name": "Logging", "children": [{ "name": "Centralized" }, { "name": "Structured" }] },
                { "name": "Alerting", "children": [{ "name": "Thresholds" }, { "name": "Escalation" }] }
              ]
            },
            {
              "name": "Reliability",
              "children": [
                { "name": "SRE", "children": [{ "name": "Toil Reduction" }, { "name": "Automation" }] },
                { "name": "Incident Mgmt", "children": [{ "name": "Triage" }, { "name": "Post-mortem" }] },
                { "name": "SLO / SLA", "children": [{ "name": "Availability" }, { "name": "Latency" }] }
              ]
            }
          ]
        },
        {
          "name": "SECURITY",
          "children": [
            {
              "name": "Access",
              "children": [
                { "name": "IAM", "children": [{ "name": "Users" }, { "name": "Groups" }] },
                { "name": "RBAC", "children": [{ "name": "Roles" }, { "name": "Permissions" }] },
                { "name": "SSO / MFA", "children": [{ "name": "SAML" }, { "name": "TOTP" }] }
              ]
            },
            {
              "name": "Protection",
              "children": [
                { "name": "Encryption", "children": [{ "name": "At Rest" }, { "name": "In Transit" }] },
                { "name": "Secrets Mgmt", "children": [{ "name": "Key Vault" }, { "name": "Rotation" }] },
                { "name": "Zero Trust", "children": [{ "name": "Verify" }, { "name": "Least Privilege" }] }
              ]
            },
            {
              "name": "Compliance",
              "children": [
                { "name": "Auditing", "children": [{ "name": "Logs" }, { "name": "Trails" }] },
                { "name": "Risk Assessment", "children": [{ "name": "TRA" }, { "name": "Mitigation" }] },
                { "name": "Policy", "children": [{ "name": "Standards" }, { "name": "Controls" }] }
              ]
            }
          ]
        },
        {
          "name": "AI/ML",
          "children": [
            {
              "name": "Fundamentals",
              "children": [
                { "name": "Supervised", "children": [{ "name": "Classification" }, { "name": "Regression" }] },
                { "name": "Unsupervised", "children": [{ "name": "Clustering" }, { "name": "Reduction" }] },
                { "name": "Deep Learning", "children": [{ "name": "Neural Nets" }, { "name": "Layers" }] }
              ]
            },
            {
              "name": "Operations",
              "children": [
                { "name": "MLOps", "children": [{ "name": "Pipelines" }, { "name": "Versioning" }] },
                { "name": "Model Training", "children": [{ "name": "Features" }, { "name": "Tuning" }] },
                { "name": "Inference", "children": [{ "name": "Batch" }, { "name": "Real-time" }] }
              ]
            },
            {
              "name": "GenAI",
              "children": [
                { "name": "LLMs", "children": [{ "name": "Tokens" }, { "name": "Context" }] },
                { "name": "Prompting", "children": [{ "name": "Few-shot" }, { "name": "Chain-of-Thought" }] },
                { "name": "RAG", "children": [{ "name": "Retrieval" }, { "name": "Augmentation" }] }
              ]
            }
          ]
        },
        {
          "name": "PM",
          "children": [
            {
              "name": "Planning",
              "children": [
                { "name": "Scope", "children": [{ "name": "Requirements" }, { "name": "WBS" }] },
                { "name": "Schedule", "children": [{ "name": "Milestones" }, { "name": "Dependencies" }] },
                { "name": "Budget", "children": [{ "name": "Estimates" }, { "name": "Tracking" }] }
              ]
            },
            {
              "name": "Execution",
              "children": [
                { "name": "Agile / Scrum", "children": [{ "name": "Sprints" }, { "name": "Ceremonies" }] },
                { "name": "Risk Mgmt", "children": [{ "name": "Register" }, { "name": "Mitigation" }] },
                { "name": "Stakeholders", "children": [{ "name": "RACI" }, { "name": "Communication" }] }
              ]
            },
            {
              "name": "Delivery",
              "children": [
                { "name": "Milestones", "children": [{ "name": "Gates" }, { "name": "Reviews" }] },
                { "name": "Change Mgmt", "children": [{ "name": "CCB" }, { "name": "Impact" }] },
                { "name": "Governance", "children": [{ "name": "Reporting" }, { "name": "Decisions" }] }
              ]
            }
          ]
        },
        {
          "name": "PROGRAMMING",
          "children": [
            {
              "name": "Fundamentals",
              "children": [
                { "name": "Data Structures", "children": [{ "name": "Arrays" }, { "name": "Hash Maps" }] },
                { "name": "Algorithms", "children": [{ "name": "Sorting" }, { "name": "Searching" }] },
                { "name": "Big O", "children": [{ "name": "Time" }, { "name": "Space" }] }
              ]
            },
            {
              "name": "Languages",
              "children": [
                { "name": "Python", "children": [{ "name": "Libraries" }, { "name": "Syntax" }] },
                { "name": "SQL", "children": [{ "name": "Queries" }, { "name": "Joins" }] },
                { "name": "JavaScript", "children": [{ "name": "ES6+" }, { "name": "Async" }] }
              ]
            },
            {
              "name": "Practices",
              "children": [
                { "name": "Version Control", "children": [{ "name": "Git" }, { "name": "Branching" }] },
                { "name": "Code Review", "children": [{ "name": "PRs" }, { "name": "Feedback" }] },
                { "name": "Documentation", "children": [{ "name": "Comments" }, { "name": "README" }] }
              ]
            }
          ]
        },
        {
          "name": "BUSINESS",
          "children": [
            {
              "name": "Finance",
              "children": [
                { "name": "CapEx / OpEx", "children": [{ "name": "Capital" }, { "name": "Operating" }] },
                { "name": "ROI / TCO", "children": [{ "name": "Returns" }, { "name": "Costs" }] },
                { "name": "Business Case", "children": [{ "name": "Benefits" }, { "name": "Justification" }] }
              ]
            },
            {
              "name": "Contracts",
              "children": [
                { "name": "SLA", "children": [{ "name": "Uptime" }, { "name": "Penalties" }] },
                { "name": "SOW", "children": [{ "name": "Deliverables" }, { "name": "Timeline" }] },
                { "name": "Procurement", "children": [{ "name": "RFP" }, { "name": "Evaluation" }] }
              ]
            },
            {
              "name": "Metrics",
              "children": [
                { "name": "KPIs", "children": [{ "name": "Targets" }, { "name": "Tracking" }] },
                { "name": "OKRs", "children": [{ "name": "Objectives" }, { "name": "Key Results" }] },
                { "name": "Reporting", "children": [{ "name": "Dashboards" }, { "name": "Insights" }] }
              ]
            }
          ]
        }
      ]
    };

    const categoryColors = {
      'DATA': '#5E8CED',
      'SOFTWARE': '#7C6AEF',
      'CLOUD': '#00B8D9',
      'DEVOPS': '#36B37E',
      'SECURITY': '#FFAB00',
      'AI/ML': '#E667AB',
      'PM': '#9061F9',
      'PROGRAMMING': '#00C7B7',
      'BUSINESS': '#FF8B00'
    };

    const width = 1000;
    const height = 1000;
    const radius = Math.min(width, height) / 2;

    const centerRadius = 65;
    const level1Width = 85;
    const level2Width = 95;
    const level3Width = 100;
    const level4Width = 80;

    const svg = d3.select('#sunburst')
      .append('svg')
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('width', width)
      .attr('height', height)
      .style('font', '10px IBM Plex Sans, sans-serif')
      .append('g')
      .attr('transform', `translate(${width / 2},${height / 2})`);

    const partition = d3.partition()
      .size([2 * Math.PI, radius]);

    const root = d3.hierarchy(data)
      .sum(d => d.children ? 0 : 1)
      .sort((a, b) => b.value - a.value);

    partition(root);

    const arc = d3.arc()
      .startAngle(d => d.x0)
      .endAngle(d => d.x1)
      .padAngle(0.002)
      .padRadius(radius / 4)
      .innerRadius(d => {
        if (d.depth === 0) return 0;
        if (d.depth === 1) return centerRadius;
        if (d.depth === 2) return centerRadius + level1Width;
        if (d.depth === 3) return centerRadius + level1Width + level2Width;
        if (d.depth === 4) return centerRadius + level1Width + level2Width + level3Width;
        return d.y0;
      })
      .outerRadius(d => {
        if (d.depth === 0) return centerRadius;
        if (d.depth === 1) return centerRadius + level1Width;
        if (d.depth === 2) return centerRadius + level1Width + level2Width;
        if (d.depth === 3) return centerRadius + level1Width + level2Width + level3Width;
        if (d.depth === 4) return centerRadius + level1Width + level2Width + level3Width + level4Width;
        return d.y1;
      });

    function getColor(d) {
      if (d.depth === 0) return '#1A1A1A';
      
      let ancestor = d;
      while (ancestor.depth > 1) ancestor = ancestor.parent;
      
      const baseColor = categoryColors[ancestor.data.name] || '#6366f1';
      const color = d3.color(baseColor);
      
      if (d.depth === 1) return baseColor;
      if (d.depth === 2) return color.brighter(0.3).formatHex();
      if (d.depth === 3) return color.brighter(0.55).formatHex();
      if (d.depth === 4) return color.brighter(0.8).formatHex();
      
      return baseColor;
    }

    function getOpacity(d) {
      if (d.depth === 0) return 1;
      if (d.depth === 1) return 0.95;
      if (d.depth === 2) return 0.9;
      if (d.depth === 3) return 0.85;
      return 0.8;
    }

    svg.selectAll('path')
      .data(root.descendants())
      .join('path')
      .attr('d', arc)
      .attr('fill', getColor)
      .attr('fill-opacity', getOpacity)
      .attr('stroke', '#0D0D0D')
      .attr('stroke-width', 0.5);

    const centerGroup = svg.append('g').attr('class', 'center-text');
    
    centerGroup.append('text')
      .attr('x', 0)
      .attr('y', -12)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#FAFAFA')
      .attr('font-family', 'IBM Plex Sans, sans-serif')
      .attr('font-size', '12px')
      .attr('font-weight', '600')
      .text('TPM');

    centerGroup.append('text')
      .attr('x', 0)
      .attr('y', 6)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#FAFAFA')
      .attr('font-family', 'IBM Plex Sans, sans-serif')
      .attr('font-size', '10px')
      .attr('font-weight', '400')
      .text('Knowledge');

    centerGroup.append('text')
      .attr('x', 0)
      .attr('y', 22)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#FAFAFA')
      .attr('font-family', 'IBM Plex Sans, sans-serif')
      .attr('font-size', '10px')
      .attr('font-weight', '400')
      .text('Base');

    // Labels for Level 1 (L1 Categories)
    svg.selectAll('.label-level1')
      .data(root.descendants().filter(d => d.depth === 1))
      .join('text')
      .attr('class', 'label-level1')
      .attr('transform', d => {
        const angle = (d.x0 + d.x1) / 2;
        const r = centerRadius + level1Width / 2;
        const x = Math.sin(angle) * r;
        const y = -Math.cos(angle) * r;
        let rotation = (angle * 180 / Math.PI) - 90;
        if (rotation > 90) rotation -= 180;
        return `translate(${x},${y}) rotate(${rotation})`;
      })
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#0D0D0D')
      .attr('font-size', '11px')
      .attr('font-weight', '600')
      .attr('letter-spacing', '0.02em')
      .text(d => d.data.name);

    // Labels for Level 2 (L2 Subcategories)
    svg.selectAll('.label-level2')
      .data(root.descendants().filter(d => d.depth === 2))
      .join('text')
      .attr('class', 'label-level2')
      .attr('transform', d => {
        const angle = (d.x0 + d.x1) / 2;
        const r = centerRadius + level1Width + (level2Width / 2);
        const x = Math.sin(angle) * r;
        const y = -Math.cos(angle) * r;
        let rotation = (angle * 180 / Math.PI) - 90;
        if (rotation > 90) rotation -= 180;
        return `translate(${x},${y}) rotate(${rotation})`;
      })
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#0D0D0D')
      .attr('font-size', '10px')
      .attr('font-weight', '500')
      .text(d => d.data.name);

    // Labels for Level 3 (L3 Topics)
    svg.selectAll('.label-level3')
      .data(root.descendants().filter(d => d.depth === 3))
      .join('text')
      .attr('class', 'label-level3')
      .attr('transform', d => {
        const angle = (d.x0 + d.x1) / 2;
        const r = centerRadius + level1Width + level2Width + (level3Width / 2);
        const x = Math.sin(angle) * r;
        const y = -Math.cos(angle) * r;
        let rotation = (angle * 180 / Math.PI) - 90;
        if (rotation > 90) rotation -= 180;
        return `translate(${x},${y}) rotate(${rotation})`;
      })
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#1A1A1A')
      .attr('font-size', '7.5px')
      .attr('font-weight', '400')
      .text(d => d.data.name);

    // Labels for Level 4 (L4 Details)
    svg.selectAll('.label-level4')
      .data(root.descendants().filter(d => d.depth === 4))
      .join('text')
      .attr('class', 'label-level4')
      .attr('transform', d => {
        const angle = (d.x0 + d.x1) / 2;
        const r = centerRadius + level1Width + level2Width + level3Width + (level4Width / 2);
        const x = Math.sin(angle) * r;
        const y = -Math.cos(angle) * r;
        let rotation = (angle * 180 / Math.PI) - 90;
        if (rotation > 90) rotation -= 180;
        return `translate(${x},${y}) rotate(${rotation})`;
      })
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('fill', '#2A2A2A')
      .attr('font-size', '6px')
      .attr('font-weight', '400')
      .text(d => d.data.name);

    // Build legend
    const legend = d3.select('#legend');
    Object.entries(categoryColors).forEach(([name, color]) => {
      const item = legend.append('div')
        .attr('class', 'legend-item');
      
      item.append('div')
        .attr('class', 'legend-color')
        .style('background', color);
      
      item.append('span')
        .attr('class', 'legend-label')
        .text(name);
    });

    // Export functions
    function exportSVG() {
      const svgElement = document.querySelector('#sunburst svg');
      const svgClone = svgElement.cloneNode(true);
      
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bg.setAttribute('width', '100%');
      bg.setAttribute('height', '100%');
      bg.setAttribute('fill', '#0D0D0D');
      svgClone.insertBefore(bg, svgClone.firstChild);
      
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
      style.textContent = `
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600&display=swap');
        text { font-family: 'IBM Plex Sans', Arial, sans-serif; }
      `;
      defs.appendChild(style);
      svgClone.insertBefore(defs, svgClone.firstChild);
      
      const svgData = new XMLSerializer().serializeToString(svgClone);
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = 'TPM-Knowledge-Sunburst.svg';
      link.click();
      URL.revokeObjectURL(url);
    }

    function exportPNG() {
      const svgElement = document.querySelector('#sunburst svg');
      const svgClone = svgElement.cloneNode(true);
      
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bg.setAttribute('width', '100%');
      bg.setAttribute('height', '100%');
      bg.setAttribute('fill', '#0D0D0D');
      svgClone.insertBefore(bg, svgClone.firstChild);
      
      const svgData = new XMLSerializer().serializeToString(svgClone);
      const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(svgBlob);
      
      const img = new Image();
      img.onload = function() {
        const scale = 3;
        const canvas = document.createElement('canvas');
        canvas.width = width * scale;
        canvas.height = height * scale;
        
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);
        ctx.fillStyle = '#0D0D0D';
        ctx.fillRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);
        
        const pngUrl = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = pngUrl;
        link.download = 'TPM-Knowledge-Sunburst.png';
        link.click();
        
        URL.revokeObjectURL(url);
      };
      img.src = url;
    }
  </script>
</body>
</html>
